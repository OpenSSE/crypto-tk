//
// libsse_crypto - An abstraction layer for high level cryptographic features.
// Copyright (C) 2015-2017 Raphael Bost
//
// This file is part of libsse_crypto.
//
// libsse_crypto is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// libsse_crypto is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with libsse_crypto.  If not, see <http://www.gnu.org/licenses/>.
//

#pragma once

#include <sse/crypto/key.hpp>
#include <sse/crypto/prf.hpp>
#include <sse/crypto/random.hpp>

#include <algorithm>
#include <array>
#include <exception>
#include <vector>

#include <sodium/crypto_stream_chacha20.h>
#include <sodium/utils.h>

namespace sse {
namespace crypto {

/// @class Wrapper
/// @brief Secure wrapping of cryptographic objects.
///
/// Wrapper is a class used to wrap (and unwrap) OpenSSE cryptographic objects.
/// It can be used to securely serialize and transmit such objects.
/// To do so, it implements nonce-misuse resistant authenticated encryption (a
/// variant of SIV with an additional random nonce).
///
/// The objects meant to be wrapped must declare/implement
///     - the constexpr size_t kPublicContextSize static variable, which denotes
///     the size of the public context of the object (e.g. the number of output
///     bytes of a PRF);
///     - the size_t serialized_size() const member function, which outputs the
///     number of bytes necessary to encode the object;
///     - the void serialize(uint8_t* out) const member function, which writes
///     the binary representation of the object into out;
///     - the CryptoClass deserialize(uint8_t* in, size_t in_size, size_t
///     n_bytes_read) static function, which outputs a new instance of the
///     CryptoClass object, initialized with the content of the in buffer, which
///     is in_size bytes wide, and put the number of read bytes in n_bytes_read;
///     - the std::array<uint8_t, kPublicContextSize> public_context() static
///     function, which outputs the public context of the object, i.e. some
///     public information related to the object (such as the number of output
///     bytes of a PRF).
/// Finally, the Wrapper::TypeByte<CryptoClass> templated member
/// struct must also be specialized for each wrappable object, to define a
/// unique `value` static value.It is **CRUCIAL** for security that each
/// specialization outputs a different type byte: collision among type bytes
/// could create a security threat.
///
/// More in detail, to encrypt an object, the Wrapper class creates a buffer
/// whose layout is the following (the bottom row indicate the size in bytes):
/// | item  | random IV     | type byte | public context     | serialization   |
/// |-------|---------------|-----------|--------------------|-----------------|
/// |size(B)| kRandomIVSize | 1         | kPublicContextSize |serialized_size()|
/// A PRF is applied to this buffer to compute the tag `T`, which is itself used
/// as the initialization vector of the (unauthenticated) encryption scheme used
/// to encrypt the serialization (currently ChaCha20 - IETF). The ciphertext is
/// the concatenation (it that order) of the random IV, the encrypted
/// serialization, and the tag.
///
/// The decryption does the inverse: it copies the random IV to a buffer,
/// concatenates the object's class type byte and public context, and appends
/// the decryption of the serialization part of the ciphertext (decrypted using
/// the ciphertext's tag as the IV). The Wrapper class then computes the PRF on
/// this buffer and checks, in constant time, that the ciphertext's tag is
/// identical to the computed tag. If it is not the case, an exception is
/// raised.
class Wrapper
{
public:
    /// @brief Wrapper key size (in bytes)
    static constexpr size_t kKeySize = 32;

    /// @brief Size (in bytes) of the tag (which is also the synthetic IV)
    static constexpr uint16_t kTagSize = 12U;

    /// @brief Size (in bytes) of the random IV to be generated.
    static constexpr size_t kRandomIVSize = 16U;

    /// @brief Number of additional bytes in a ciphertext generated by a Wrapper
    static constexpr size_t kCiphertextExpansion = kTagSize + kRandomIVSize;

    Wrapper() = delete;


    ///
    /// @brief Constructor
    ///
    /// Creates a Wrapper object from a 32 bytes (256 bits) key.
    /// After a call to the constructor, the input key is
    /// held by the Wrapper object, and cannot be re-used.
    ///
    /// @param key  The key used to initialize the wrapper.
    ///             Upon return, key is empty
    ///
    explicit Wrapper(Key<kKeySize>&& key);

    // deleted copy constructor and operator
    Wrapper(const Wrapper& w) = delete;
    Wrapper& operator=(const Wrapper& w) = delete;


    /// @brief Move constructor
    Wrapper(Wrapper&& w) = default;

    /// @brief Move assignment operator
    Wrapper& operator=(Wrapper&& w) = default;

    ///
    /// @brief Wrap a cryptographic object
    ///
    /// Wraps a cryptographic object by serializing it and encrypting its binary
    /// representation. Authenticated encryption is used to ensure
    /// confidentiality and integrity of the wrapped object.
    ///
    /// @tparam CryptoClass     The class of the object to be wrapped. The class
    ///                         must declare the kPublicContextSize static
    ///                         variable and implement the size_t
    ///                         serialized_size(), and void serialize(uint8_t*)
    ///                         const member functions and std::array<uint8_t,
    ///                         kPublicContextSize>public_context() static
    ///                         function.
    ///                         The Wrapper::TypeByte<CryptoClass> static
    ///                         struct must be specialized for CryptoClass.
    ///
    /// @param c    The object to be wrapped.
    ///
    /// @return A buffer containing the encrypted representation of the wrapped
    ///         object
    template<class CryptoClass>
    std::vector<uint8_t> wrap(const CryptoClass& c) const;

    ///
    /// @brief Unwrap a cryptographic object
    ///
    /// Unwraps a cryptographic object by decrypting it and deserialize the
    /// result. Authenticated encryption is used to ensure confidentiality
    /// and integrity of the wrapped object, and the function throws if the
    /// ciphertext is invalid.
    ///
    /// @tparam CryptoClass     The class of the object to be wrapped. The
    /// class
    ///                         must declare the kPublicContextSize static
    ///                         variable, and implement the CryptoClass
    ///                         deserialize(uint8_t*, size_t, size_t&) static
    ///                         function and std::array<uint8_t,
    ///                         kPublicContextSize>public_context() static
    ///                         function.
    ///                         The Wrapper::TypeByte<CryptoClass> static
    ///                         struct must be specialized for CryptoClass.
    ///
    /// @param c_rep    The buffer containing the encrypted representation of
    ///                 the object.
    ///
    /// @return     The object represented by the encrypted buffer.
    ///
    /// @exception std::runtime_error   The decryption failed:
    ///                                 invalid tag
    ///
    template<class CryptoClass>
    CryptoClass unwrap(std::vector<uint8_t>& c_rep) const;

    static constexpr size_t kDefaultTypeByte = 0x00;

private:
    template<class CryptoClass>
    struct TypeByte
    {
        static constexpr uint8_t value = kDefaultTypeByte;
    };

    static constexpr uint16_t kEncryptionKeySize = 32U;

    Prf<kTagSize>           tag_generator_;
    Key<kEncryptionKeySize> encryption_key_;
};

template<class CryptoClass>
std::vector<uint8_t> Wrapper::wrap(const CryptoClass& c) const
{
    const size_t serialized_size = c.serialized_size();
    const size_t buffer_size     = kRandomIVSize + serialized_size
                               + CryptoClass::kPublicContextSize
                               + 1; // the +1 is for the mandatory type byte
    uint8_t* buffer = static_cast<uint8_t*>(sodium_malloc(buffer_size));
    // std::array<uint8_t, buffer_size> buffer;

    // put the random IV at the beggining
    random_bytes(kRandomIVSize, buffer);
    // put the type byte after the IV
    static_assert(Wrapper::TypeByte<CryptoClass>::value != kDefaultTypeByte,
                  "Wrapping is not implemented for the class.");
    buffer[kRandomIVSize] = Wrapper::TypeByte<CryptoClass>::value;
    // copy the AD

    if (CryptoClass::kPublicContextSize > 0) {
        std::array<uint8_t, CryptoClass::kPublicContextSize> public_context
            = CryptoClass::public_context();
        memcpy(buffer + kRandomIVSize + 1,
               public_context.data(),
               CryptoClass::kPublicContextSize);
    }
    // Serialize the object in the buffer
    constexpr size_t serialization_offset
        = +kRandomIVSize + 1 + CryptoClass::kPublicContextSize;
    c.serialize(buffer + serialization_offset);

    std::vector<uint8_t> out(kCiphertextExpansion + serialized_size);

    // copy the IV at the beggining of the output
    memcpy(out.data(), buffer, kRandomIVSize);

    // compute the tag and put it at the end of the ciphertext
    std::array<uint8_t, kTagSize> tag = tag_generator_.prf(buffer, buffer_size);
    std::copy_n(tag.begin(), kTagSize, out.end() - kTagSize);

    // encrypt the secret part of the buffer
    crypto_stream_chacha20_ietf_xor(out.data() + kRandomIVSize,
                                    buffer + serialization_offset,
                                    serialized_size,
                                    tag.data(),
                                    encryption_key_.unlock_get());
    encryption_key_.lock();

    sodium_free(buffer);

    return out;
}

template<class CryptoClass>
CryptoClass Wrapper::unwrap(std::vector<uint8_t>& c_rep) const
{
    if (c_rep.size() <= kCiphertextExpansion) {
        throw std::invalid_argument(
            "Wrapper::unwrap: wrapper size is too small.");
    }

    const size_t data_size   = c_rep.size() - kCiphertextExpansion;
    const size_t buffer_size = kRandomIVSize + data_size
                               + CryptoClass::kPublicContextSize
                               + 1; // the +1 is for the mandatory type byte
    uint8_t* buffer = static_cast<uint8_t*>(sodium_malloc(buffer_size));
    // std::array<uint8_t, buffer_size> buffer;

    // copy the IV at the beggining of the buffer
    memcpy(buffer, c_rep.data(), kRandomIVSize);
    // std::copy_n(c_rep.begin(), kRandomIVSize, buffer.begin());

    // put the type byte after the IV
    buffer[kRandomIVSize] = Wrapper::TypeByte<CryptoClass>::value;

    // copy the AD
    if (CryptoClass::kPublicContextSize > 0) {
        std::array<uint8_t, CryptoClass::kPublicContextSize> public_context
            = CryptoClass::public_context();
        memcpy(buffer + kRandomIVSize + 1,
               public_context.data(),
               CryptoClass::kPublicContextSize);
    }
    // put the expected tag in a dedicated array
    std::array<uint8_t, kTagSize> expected_tag;
    std::copy_n(c_rep.end() - kTagSize, kTagSize, expected_tag.begin());

    // decrypt the representation
    constexpr size_t serialization_offset
        = +kRandomIVSize + 1 + CryptoClass::kPublicContextSize;

    crypto_stream_chacha20_ietf_xor(buffer + serialization_offset,
                                    c_rep.data() + kRandomIVSize,
                                    data_size,
                                    expected_tag.data(),
                                    encryption_key_.unlock_get());
    encryption_key_.lock();


    // re-compute the tag
    std::array<uint8_t, kTagSize> computed_tag
        = tag_generator_.prf(buffer, buffer_size);

    // check that the computed tag and the expected tag are the same
    if (sodium_memcmp(expected_tag.data(), computed_tag.data(), kTagSize)
        != 0) {
        throw std::runtime_error(
            "Wrapper::unwrap: decryption failed, invalid tag!");
    }

    // Deserialize the buffer
    size_t      bytes_read = 0;
    CryptoClass c          = CryptoClass::deserialize(
        buffer + kRandomIVSize + 1 + CryptoClass::kPublicContextSize,
        data_size,
        bytes_read);

    if (bytes_read != data_size) {
        /* LCOV_EXCL_START */
        throw std::runtime_error(
            "Wrapper::unwrap: the number of read bytes ("
            + std::to_string(bytes_read)
            + ") is different from the number of data bytes ("
            + std::to_string(data_size) + ")");
        /* LCOV_EXCL_STOP */
    }

    // free the buffer and zero the entry
    sodium_free(buffer);
    sodium_memzero(c_rep.data(), c_rep.size());

    return c;
}

// Specializations of the Wrapper::TypeByte<CryptoClass> template

class Cipher;
template<>
struct Wrapper::TypeByte<Cipher>
{
    static constexpr uint8_t value = 0x01;
};

template<uint16_t NBYTES>
class Prf;
template<uint16_t NBYTES>
struct Wrapper::TypeByte<Prf<NBYTES>>
{
    static constexpr uint8_t value = 0x02;
};

class Prg;
template<>
struct Wrapper::TypeByte<Prg>
{
    static constexpr uint8_t value = 0x03;
};

class Prp;
template<>
struct Wrapper::TypeByte<Prp>
{
    static constexpr uint8_t value = 0x04;
};


template<uint16_t NBYTES>
class RCPrf;
template<uint16_t NBYTES>
struct Wrapper::TypeByte<RCPrf<NBYTES>>
{
    static constexpr uint8_t value = 0x06;
};

template<uint16_t NBYTES>
class ConstrainedRCPrf;
template<uint16_t NBYTES>
struct Wrapper::TypeByte<ConstrainedRCPrf<NBYTES>>
{
    static constexpr uint8_t value = 0x06;
};

class TdpInverse;
template<>
struct Wrapper::TypeByte<TdpInverse>
{
    static constexpr uint8_t value = 0x07;
};

} // namespace crypto
} // namespace sse
