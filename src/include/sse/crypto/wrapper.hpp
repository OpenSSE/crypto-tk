//
// libsse_crypto - An abstraction layer for high level cryptographic features.
// Copyright (C) 2015-2017 Raphael Bost
//
// This file is part of libsse_crypto.
//
// libsse_crypto is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// libsse_crypto is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with libsse_crypto.  If not, see <http://www.gnu.org/licenses/>.
//

#pragma once

#include <sse/crypto/key.hpp>
#include <sse/crypto/prf.hpp>
#include <sse/crypto/random.hpp>

#include <algorithm>
#include <array>

#include <sodium/crypto_stream_chacha20.h>
#include <sodium/utils.h>

namespace sse {
namespace crypto {

/// @class Wrapper
/// @brief Secure wrapping of cryptographic objects.
///
/// Wrapper is a class used to wrap (and unwrap) OpenSSE cryptographic objects.
/// It can be used to securely serialize and transmit such objects.
/// To do so, it implements nonce-misuse resistant authenticated encryption (a
/// variant of SIV with an additional random nonce).
///
/// The objects meant to be wrapped must declare/implement
///     - the constexpr size_t kSerializedSize static variable, which denotes
///     the size of the binary representation of the object;
///     - the constexpr size_t kPublicContextSize static variable, which denotes
///     the size of the public context of the object (e.g. the number of output
///     bytes of a PRF);
///     - the void serialize(uint8_t* out) const member function, which writes
///     the binary representation of the object into out;
///     - the CryptoClass deserialize(uint8_t* in) static function, which
///     outputs a new instance of the CryptoClass object, initialized with the
///     content of the in buffer;
///     - the std::array<uint8_t, kPublicContextSize> public_context() static
///     function, which outputs the public context of the object, i.e. some
///     public information related to the object (such as the number of output
///     bytes of a PRF).
/// Finally, the get_type_byte() templated member function must also be
/// specialized for each wrappable object. It is **CRUCIAL** for security that
/// each specialization outputs a different type byte: collision among type
/// bytes could create a security threat.
///
/// More in detail, to encrypt an object, the Wrapper class creates a buffer
/// whose layout is the following (the bottom row indicate the size in bytes):
/// | item  | random IV     | type byte | public context     | serialization   |
/// |-------|---------------|-----------|--------------------|-----------------|
/// |size(B)| kRandomIVSize | 1         | kPublicContextSize | kSerializedSize |
/// A PRF is applied to this buffer to compute the tag `T`, which is itself used
/// as the initialization vector of the (unauthenticated) encryption scheme used
/// to encrypt the serialization (currently ChaCha20 - IETF). The ciphertext is
/// the concatenation (it that order) of the random IV, the encrypted
/// serialization, and the tag.
///
/// The decryption does the inverse: it copies the random IV to a buffer,
/// concatenates the object's class type byte and public context, and appends
/// the decryption of the serialization part of the ciphertext (decrypted using
/// the ciphertext's tag as the IV). The Wrapper class then computes the PRF on
/// this buffer and checks, in constant time, that the ciphertext's tag is
/// identical to the computed tag. If it is not the case, an exception is
/// raised.
class Wrapper
{
public:
    /// @brief Wrapper key size (in bytes)
    static constexpr size_t kKeySize = 32;

    /// @brief Size (in bytes) of the tag (which is also the synthetic IV)
    static constexpr uint16_t kTagSize = 12U;

    /// @brief Size (in bytes) of the random IV to be generated.
    static constexpr size_t kRandomIVSize = 16U;

    /// @brief Number of additional bytes in a ciphertext generated by a Wrapper
    static constexpr size_t kCiphertextExpansion = kTagSize + kRandomIVSize;

    Wrapper() = delete;


    ///
    /// @brief Constructor
    ///
    /// Creates a Wrapper object from a 32 bytes (256 bits) key.
    /// After a call to the constructor, the input key is
    /// held by the Wrapper object, and cannot be re-used.
    ///
    /// @param key  The key used to initialize the wrapper.
    ///             Upon return, key is empty
    ///
    Wrapper(Key<kKeySize>&& key);

    // deleted copy constructor and operator
    Wrapper(const Wrapper& w) = delete;
    Wrapper& operator=(const Wrapper& w) = delete;


    /// @brief Move constructor
    Wrapper(Wrapper&& w) = default;

    /// @brief Move assignment operator
    Wrapper& operator=(Wrapper&& w) = default;

    ///
    /// @brief Wrap a cryptographic object
    ///
    /// Wraps a cryptographic object by serializing it and encrypting its binary
    /// representation. Authenticated encryption is used to ensure
    /// confidentiality and integrity of the wrapped object.
    ///
    /// @tparam CryptoClass     The class of the object to be wrapped. The class
    ///                         must declare the kSerializedSize, and
    ///                         kPublicContextSize static
    ///                         variables and implement the void
    ///                         serialize(uint8_t*) const member function and
    ///                         std::array<uint8_t,
    ///                         kPublicContextSize>public_context() static
    ///                         function.
    ///                         The Wrapper::get_type_byte() static function
    ///                         must be specialized for CryptoClass.
    ///
    /// @param c    The object to be wrapped.
    ///
    /// @return A buffer containing the encrypted representation of the wrapped
    ///         object
    // Using an auto return type avoids a compile-time error on gcc, which is
    // not able to match the templated member declaration and its definition. It
    // seems it is due to the fact that we use CryptoClass::kSerializedSize in
    // the return type. Also, clang has no problem compiling the more natural
    // declaration:
    // template<class CryptoClass> std::array<uint8_t, kCiphertextExpansion
    // + CryptoClass::kSerializedSize> wrap(const CryptoClass& c) const;
    template<class CryptoClass>
    auto wrap(const CryptoClass& c)
        -> std::array<uint8_t,
                      kCiphertextExpansion
                          + CryptoClass::kSerializedSize> const;

    ///
    /// @brief Unwrap a cryptographic object
    ///
    /// Unwraps a cryptographic object by decrypting it and deserialize the
    /// result. Authenticated encryption is used to ensure confidentiality
    /// and integrity of the wrapped object, and the function throws if the
    /// ciphertext is invalid.
    ///
    /// @tparam CryptoClass     The class of the object to be wrapped. The
    /// class
    ///                         must declare the kSerializedSize, and
    ///                         kPublicContextSize static
    ///                         variables and implement the CryptoClass
    ///                         deserialize(uint8_t*) static function and
    ///                         std::array<uint8_t,
    ///                         kPublicContextSize>public_context() static
    ///                         function.
    ///                         The Wrapper::get_type_byte() static function
    ///                         must be specialized for CryptoClass.
    ///
    /// @param c    The buffer containing the encrypted representation of
    ///             the object.
    ///
    /// @return     The object represented by the encrypted buffer.
    ///
    /// @exception std::runtime_error   The decryption failed:
    ///                                 invalid tag
    ///
    template<class CryptoClass>
    CryptoClass unwrap(
        std::array<uint8_t,
                   kCiphertextExpansion + CryptoClass::kSerializedSize>& c_rep)
        const;


    template<class CryptoClass>
    static constexpr uint8_t get_type_byte();

private:
    static constexpr uint16_t kEncryptionKeySize = 32U;

    Prf<kTagSize>           tag_generator_;
    Key<kEncryptionKeySize> encryption_key_;
};

template<class CryptoClass>
auto Wrapper::wrap(const CryptoClass& c)
    -> std::array<uint8_t,
                  kCiphertextExpansion + CryptoClass::kSerializedSize> const
{
    constexpr size_t buffer_size = kRandomIVSize + CryptoClass::kSerializedSize
                                   + CryptoClass::kPublicContextSize
                                   + 1; // the +1 is for the mandatory type byte
    uint8_t* buffer = static_cast<uint8_t*>(sodium_malloc(buffer_size));
    // std::array<uint8_t, buffer_size> buffer;

    // put the random IV at the beggining
    random_bytes(kRandomIVSize, buffer);
    // put the type byte after the IV
    buffer[kRandomIVSize] = Wrapper::get_type_byte<CryptoClass>();
    // copy the AD

    if (CryptoClass::kPublicContextSize > 0) {
        std::array<uint8_t, CryptoClass::kPublicContextSize> public_context
            = CryptoClass::public_context();
        memcpy(buffer + kRandomIVSize + 1,
               public_context.data(),
               CryptoClass::kPublicContextSize);
    }
    // Serialize the object in the buffer
    constexpr size_t serialization_offset
        = +kRandomIVSize + 1 + CryptoClass::kPublicContextSize;
    c.serialize(buffer + serialization_offset);

    std::array<uint8_t, kCiphertextExpansion + CryptoClass::kSerializedSize>
        out;

    // copy the IV at the beggining of the output
    memcpy(out.data(), buffer, kRandomIVSize);

    // compute the tag and put it at the end of the ciphertext
    std::array<uint8_t, kTagSize> tag = tag_generator_.prf(buffer, buffer_size);
    std::copy_n(tag.begin(), kTagSize, out.end() - kTagSize);

    // encrypt the secret part of the buffer
    crypto_stream_chacha20_ietf_xor(out.data() + kRandomIVSize,
                                    buffer + serialization_offset,
                                    CryptoClass::kSerializedSize,
                                    tag.data(),
                                    encryption_key_.unlock_get());
    encryption_key_.lock();

    sodium_free(buffer);

    return out;
}

template<class CryptoClass>
CryptoClass Wrapper::unwrap(
    std::array<uint8_t,
               Wrapper::kCiphertextExpansion + CryptoClass::kSerializedSize>&
        c_rep) const
{
    constexpr size_t buffer_size = kRandomIVSize + CryptoClass::kSerializedSize
                                   + CryptoClass::kPublicContextSize
                                   + 1; // the +1 is for the mandatory type byte
    uint8_t* buffer = static_cast<uint8_t*>(sodium_malloc(buffer_size));
    // std::array<uint8_t, buffer_size> buffer;

    // copy the IV at the beggining of the buffer
    memcpy(buffer, c_rep.data(), kRandomIVSize);
    // std::copy_n(c_rep.begin(), kRandomIVSize, buffer.begin());

    // put the type byte after the IV
    buffer[kRandomIVSize] = Wrapper::get_type_byte<CryptoClass>();

    // copy the AD
    if (CryptoClass::kPublicContextSize > 0) {
        std::array<uint8_t, CryptoClass::kPublicContextSize> public_context
            = CryptoClass::public_context();
        memcpy(buffer + kRandomIVSize + 1,
               public_context.data(),
               CryptoClass::kPublicContextSize);
    }
    // put the expected tag in a dedicated array
    std::array<uint8_t, kTagSize> expected_tag;
    std::copy_n(c_rep.end() - kTagSize, kTagSize, expected_tag.begin());

    // decrypt the representation
    constexpr size_t serialization_offset
        = +kRandomIVSize + 1 + CryptoClass::kPublicContextSize;

    crypto_stream_chacha20_ietf_xor(buffer + serialization_offset,
                                    c_rep.data() + kRandomIVSize,
                                    CryptoClass::kSerializedSize,
                                    expected_tag.data(),
                                    encryption_key_.unlock_get());
    encryption_key_.lock();


    // re-compute the tag
    std::array<uint8_t, kTagSize> computed_tag
        = tag_generator_.prf(buffer, buffer_size);

    // check that the computed tag and the expected tag are the same
    if (sodium_memcmp(expected_tag.data(), computed_tag.data(), kTagSize)
        != 0) {
        throw std::runtime_error("Wrapper: decryption failed, invalid tag!");
    }

    // Deserialize the buffer
    CryptoClass c = CryptoClass::deserialize(buffer + kRandomIVSize + 1
                                             + CryptoClass::kPublicContextSize);


    // free the buffer and zero the entry
    sodium_free(buffer);
    sodium_memzero(c_rep.data(), c_rep.size());

    return c;
}

// Specializations of the get_type_byte() template

class Prg;
template<>
constexpr uint8_t Wrapper::get_type_byte<Prg>()
{
    return 0x01;
}


} // namespace crypto
} // namespace sse